<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Judy Essence — Cosmic Pastel Dreamscape</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #0a0612;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Target ultrawide: 5120x1440, but we render at screen res
let W, H, dpr;

function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ── Color palette (Judy's essence) ──
const PALETTE = {
  deepSpace:   '#0a0612',
  cosmicPurple:'#2a1040',
  lavender:    '#9b7ec8',
  softPink:    '#f4a6c8',
  hotPink:     '#e8639a',
  babyBlue:    '#8ec8e8',
  skyBlue:     '#6db3d9',
  periwinkle:  '#a8b4f0',
  cream:       '#fff0f5',
  starWhite:   '#fffaf5',
  mintGlow:    '#b8f0e8',
};

// ── Nebula blobs ──
class Nebula {
  constructor() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.radius = 100 + Math.random() * 350;
    this.color = [
      PALETTE.softPink, PALETTE.lavender, PALETTE.babyBlue,
      PALETTE.periwinkle, PALETTE.hotPink, PALETTE.mintGlow,
      PALETTE.skyBlue
    ][Math.floor(Math.random() * 7)];
    this.opacity = 0.08 + Math.random() * 0.15;
    this.driftX = (Math.random() - 0.5) * 0.15;
    this.driftY = (Math.random() - 0.5) * 0.08;
    this.phase = Math.random() * Math.PI * 2;
    this.pulseSpeed = 0.0003 + Math.random() * 0.0006;
  }
  update(t) {
    this.x += this.driftX;
    this.y += this.driftY;
    if (this.x < -this.radius) this.x = W + this.radius;
    if (this.x > W + this.radius) this.x = -this.radius;
    if (this.y < -this.radius) this.y = H + this.radius;
    if (this.y > H + this.radius) this.y = -this.radius;
    this.currentOpacity = this.opacity * (0.7 + 0.3 * Math.sin(t * this.pulseSpeed + this.phase));
  }
  draw() {
    const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    grad.addColorStop(0, this.color + hexOpacity(this.currentOpacity));
    grad.addColorStop(0.5, this.color + hexOpacity(this.currentOpacity * 0.4));
    grad.addColorStop(1, this.color + '00');
    ctx.fillStyle = grad;
    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
}

// ── Stars ──
class Star {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.size = 0.3 + Math.random() * 2;
    this.twinkleSpeed = 0.001 + Math.random() * 0.004;
    this.phase = Math.random() * Math.PI * 2;
    this.brightness = 0.3 + Math.random() * 0.7;
    this.color = Math.random() > 0.6
      ? PALETTE.starWhite
      : Math.random() > 0.5
        ? PALETTE.softPink
        : PALETTE.babyBlue;
  }
  update(t) {
    this.currentBright = this.brightness * (0.4 + 0.6 * Math.sin(t * this.twinkleSpeed + this.phase));
  }
  draw() {
    ctx.save();
    ctx.globalAlpha = this.currentBright;
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = this.size * 4;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ── Sparkle (4-point star) ──
class Sparkle {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.size = 4 + Math.random() * 14;
    this.rotation = Math.random() * Math.PI;
    this.rotSpeed = (Math.random() - 0.5) * 0.0008;
    this.life = 0;
    this.maxLife = 3000 + Math.random() * 6000;
    this.color = [
      PALETTE.starWhite, PALETTE.softPink, PALETTE.babyBlue,
      PALETTE.cream, PALETTE.periwinkle, PALETTE.mintGlow
    ][Math.floor(Math.random() * 6)];
  }
  update(dt) {
    this.life += dt;
    this.rotation += this.rotSpeed * dt;
    if (this.life > this.maxLife) this.reset();
  }
  draw() {
    const progress = this.life / this.maxLife;
    // fade in, hold, fade out
    let alpha;
    if (progress < 0.15) alpha = progress / 0.15;
    else if (progress > 0.75) alpha = (1 - progress) / 0.25;
    else alpha = 1;
    alpha *= 0.85;

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = this.size * 2;
    drawFourPointStar(ctx, 0, 0, this.size, this.size * 0.18);
    ctx.restore();
  }
}

function drawFourPointStar(ctx, cx, cy, outerR, innerR) {
  const points = 4;
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const angle = (Math.PI / points) * i - Math.PI / 2;
    const x = cx + Math.cos(angle) * r;
    const y = cy + Math.sin(angle) * r;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();
}

// ── Floating orb (bokeh) ──
class Orb {
  constructor() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.radius = 15 + Math.random() * 60;
    this.opacity = 0.03 + Math.random() * 0.07;
    this.driftX = (Math.random() - 0.5) * 0.3;
    this.driftY = -0.05 - Math.random() * 0.15;
    this.color = [
      PALETTE.softPink, PALETTE.babyBlue, PALETTE.lavender,
      PALETTE.periwinkle, PALETTE.mintGlow, PALETTE.hotPink
    ][Math.floor(Math.random() * 6)];
    this.phase = Math.random() * Math.PI * 2;
  }
  update(t) {
    this.x += this.driftX + Math.sin(t * 0.0003 + this.phase) * 0.2;
    this.y += this.driftY;
    if (this.y < -this.radius * 2) {
      this.y = H + this.radius;
      this.x = Math.random() * W;
    }
    if (this.x < -this.radius) this.x = W + this.radius;
    if (this.x > W + this.radius) this.x = -this.radius;
  }
  draw() {
    ctx.save();
    const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    grad.addColorStop(0, this.color + hexOpacity(this.opacity * 1.5));
    grad.addColorStop(0.4, this.color + hexOpacity(this.opacity));
    grad.addColorStop(1, this.color + '00');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ── Shooting star ──
class ShootingStar {
  constructor() { this.active = false; this.timer = 2000 + Math.random() * 8000; }
  trigger() {
    this.active = true;
    this.x = Math.random() * W * 0.8;
    this.y = Math.random() * H * 0.4;
    this.angle = Math.PI * 0.12 + Math.random() * 0.15;
    this.speed = 4 + Math.random() * 4;
    this.length = 80 + Math.random() * 120;
    this.life = 0;
    this.maxLife = 600 + Math.random() * 400;
    this.color = Math.random() > 0.5 ? PALETTE.softPink : PALETTE.babyBlue;
  }
  update(dt) {
    if (!this.active) {
      this.timer -= dt;
      if (this.timer <= 0) this.trigger();
      return;
    }
    this.life += dt;
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    if (this.life > this.maxLife) {
      this.active = false;
      this.timer = 4000 + Math.random() * 12000;
    }
  }
  draw() {
    if (!this.active) return;
    const progress = this.life / this.maxLife;
    let alpha = progress < 0.1 ? progress / 0.1 : progress > 0.6 ? (1 - progress) / 0.4 : 1;
    const tailX = this.x - Math.cos(this.angle) * this.length;
    const tailY = this.y - Math.sin(this.angle) * this.length;

    ctx.save();
    ctx.globalAlpha = alpha * 0.9;
    const grad = ctx.createLinearGradient(tailX, tailY, this.x, this.y);
    grad.addColorStop(0, this.color + '00');
    grad.addColorStop(0.7, this.color + '88');
    grad.addColorStop(1, PALETTE.starWhite);
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(this.x, this.y);
    ctx.stroke();

    // head glow
    ctx.shadowColor = PALETTE.starWhite;
    ctx.shadowBlur = 12;
    ctx.fillStyle = PALETTE.starWhite;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ── Flowing aurora ribbon ──
class Aurora {
  constructor(yBase, color1, color2, amplitude, freq, speed) {
    this.yBase = yBase;
    this.color1 = color1;
    this.color2 = color2;
    this.amplitude = amplitude;
    this.freq = freq;
    this.speed = speed;
    this.thickness = 40 + Math.random() * 60;
    this.opacity = 0.04 + Math.random() * 0.06;
  }
  draw(t) {
    ctx.save();
    ctx.globalAlpha = this.opacity;
    const steps = 80;
    const dx = W / steps;

    for (let layer = 0; layer < 3; layer++) {
      ctx.beginPath();
      const layerOffset = layer * this.thickness * 0.3;
      for (let i = 0; i <= steps; i++) {
        const x = i * dx;
        const y = this.yBase + layerOffset +
          Math.sin(x * this.freq + t * this.speed) * this.amplitude +
          Math.sin(x * this.freq * 1.7 + t * this.speed * 0.7) * this.amplitude * 0.4;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      // close bottom
      for (let i = steps; i >= 0; i--) {
        const x = i * dx;
        const y = this.yBase + layerOffset + this.thickness +
          Math.sin(x * this.freq + t * this.speed + 0.5) * this.amplitude * 0.6 +
          Math.sin(x * this.freq * 1.3 + t * this.speed * 0.5) * this.amplitude * 0.3;
        ctx.lineTo(x, y);
      }
      ctx.closePath();

      const grad = ctx.createLinearGradient(0, this.yBase, W, this.yBase);
      grad.addColorStop(0, this.color1);
      grad.addColorStop(0.5, this.color2);
      grad.addColorStop(1, this.color1);
      ctx.fillStyle = grad;
      ctx.fill();
    }
    ctx.restore();
  }
}

// ── Utility ──
function hexOpacity(a) {
  return Math.round(Math.min(1, Math.max(0, a)) * 255).toString(16).padStart(2, '0');
}

// ── Create entities ──
const nebulaCount = 18;
const starCount = 400;
const sparkleCount = 45;
const orbCount = 35;
const shootingStarCount = 3;

let nebulae = [], stars = [], sparkles = [], orbs = [], shootingStars = [], auroras = [];

function init() {
  nebulae = Array.from({length: nebulaCount}, () => new Nebula());
  stars = Array.from({length: starCount}, () => new Star());
  sparkles = Array.from({length: sparkleCount}, () => new Sparkle());
  orbs = Array.from({length: orbCount}, () => new Orb());
  shootingStars = Array.from({length: shootingStarCount}, () => new ShootingStar());
  auroras = [
    new Aurora(H * 0.25, PALETTE.softPink, PALETTE.lavender, 30, 0.003, 0.0004),
    new Aurora(H * 0.55, PALETTE.babyBlue, PALETTE.periwinkle, 25, 0.004, -0.0003),
    new Aurora(H * 0.75, PALETTE.hotPink, PALETTE.mintGlow, 20, 0.0025, 0.00035),
  ];
}
init();
window.addEventListener('resize', () => { resize(); init(); });

// ── Background gradient ──
function drawBackground(t) {
  // Deep cosmic background with slow color shift
  const shift = Math.sin(t * 0.00005) * 10;
  const grad = ctx.createLinearGradient(0, 0, W, H);
  grad.addColorStop(0, '#0e0520');
  grad.addColorStop(0.25, '#1a0a35');
  grad.addColorStop(0.5, '#150830');
  grad.addColorStop(0.75, '#0d0a28');
  grad.addColorStop(1, '#0a0618');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Central warm glow
  const cx = W * (0.5 + Math.sin(t * 0.00008) * 0.1);
  const cy = H * (0.45 + Math.cos(t * 0.00006) * 0.05);
  const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, H * 1.2);
  glow.addColorStop(0, PALETTE.softPink + '18');
  glow.addColorStop(0.3, PALETTE.lavender + '0d');
  glow.addColorStop(0.6, PALETTE.babyBlue + '08');
  glow.addColorStop(1, '#00000000');
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, W, H);

  // Secondary glow (right side, blue)
  const cx2 = W * 0.8;
  const cy2 = H * 0.3;
  const glow2 = ctx.createRadialGradient(cx2, cy2, 0, cx2, cy2, H * 0.8);
  glow2.addColorStop(0, PALETTE.babyBlue + '10');
  glow2.addColorStop(0.5, PALETTE.periwinkle + '08');
  glow2.addColorStop(1, '#00000000');
  ctx.fillStyle = glow2;
  ctx.fillRect(0, 0, W, H);

  // Left side pink glow
  const cx3 = W * 0.15;
  const cy3 = H * 0.6;
  const glow3 = ctx.createRadialGradient(cx3, cy3, 0, cx3, cy3, H * 0.7);
  glow3.addColorStop(0, PALETTE.hotPink + '0e');
  glow3.addColorStop(0.4, PALETTE.softPink + '08');
  glow3.addColorStop(1, '#00000000');
  ctx.fillStyle = glow3;
  ctx.fillRect(0, 0, W, H);
}

// ── Stardust veil ──
let dustParticles = [];
for (let i = 0; i < 200; i++) {
  dustParticles.push({
    x: Math.random() * 6000,
    y: Math.random() * 2000,
    size: 0.2 + Math.random() * 0.8,
    opacity: 0.1 + Math.random() * 0.3,
    speed: 0.02 + Math.random() * 0.05,
  });
}

function drawDust(t) {
  ctx.save();
  dustParticles.forEach(p => {
    p.x += p.speed;
    if (p.x > W + 10) p.x = -10;
    const flicker = 0.5 + 0.5 * Math.sin(t * 0.002 + p.x * 0.01);
    ctx.globalAlpha = p.opacity * flicker;
    ctx.fillStyle = PALETTE.cream;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();
}

// ── Main loop ──
let lastTime = 0;
function animate(timestamp) {
  const dt = lastTime ? timestamp - lastTime : 16;
  lastTime = timestamp;

  drawBackground(timestamp);

  // Nebulae (back layer)
  ctx.globalCompositeOperation = 'screen';
  nebulae.forEach(n => { n.update(timestamp); n.draw(); });
  ctx.globalCompositeOperation = 'source-over';

  // Aurora ribbons
  auroras.forEach(a => a.draw(timestamp));

  // Dust
  drawDust(timestamp);

  // Orbs (bokeh)
  ctx.globalCompositeOperation = 'screen';
  orbs.forEach(o => { o.update(timestamp); o.draw(); });
  ctx.globalCompositeOperation = 'source-over';

  // Stars
  stars.forEach(s => { s.update(timestamp); s.draw(); });

  // Sparkles
  sparkles.forEach(s => { s.update(dt); s.draw(); });

  // Shooting stars
  shootingStars.forEach(s => { s.update(dt); s.draw(); });

  // Subtle vignette
  const vig = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, Math.max(W, H) * 0.75);
  vig.addColorStop(0, '#00000000');
  vig.addColorStop(1, '#0a051240');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>
</body>
</html>
